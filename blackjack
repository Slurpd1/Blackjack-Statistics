from shoe import Shoe
from hand import *
from card import Card
from basic_strategy import *
import sqlite3
import uuid
import sqlite3
import pandas as pd # type: ignore
import plotly.graph_objs as go # type: ignore
import plotly.express as px # type: ignore

# connect to sql db to store games
connection = sqlite3.connect('blackjack_statistics')
cursor = connection.cursor()

#cursor.execute('DROP TABLE IF EXISTS blackjack_statistics')
cursor.execute('DROP TABLE IF EXISTS blackjack_statistics')


cursor.execute('''CREATE TABLE IF NOT EXISTS blackjack_statistics (
                    id TEXT PRIMARY KEY,
                    initial_hand_player TEXT,
                    type TEXT,
                    init_total_player INTEGER,
                    dealer_up TEXT,
                    decision_init_player TEXT,
                    split TEXT,
                    dealer_total TEXT,
                    player_total INTEGER,
                    win INTEGER,
                    outcome_type TEXT,
                    win_multiplier FLOAT,
                    
                    split_init_hand_1 TEXT,
                    split_init_type_1 TEXT,
                    split_decision_init_1 TEXT,
                    split_total_1 TEXT,
                    split_win_1 TEXT,
                    split_win_multiplier_1 FLOAT,
               
                    split_init_hand_2 TEXT,
                    split_init_type_2 TEXT,
                    split_decision_init_2 TEXT,
                    split_total_2 TEXT,
                    split_win_2 TEXT,
                    split_win_multiplier_2 FLOAT
                )''')


def blackjack_statistics(iterations=1000, shoe_size=4):
    '''
    Main function for playing the game of blackjack and aquiring data associated with games.
    Parameters:
    iterations - the number of times a game of blackjack will be played.
    shoe_size - the number of decks that will be used in the shoe
    '''

    shoe = Shoe(shoe_size) # always start with a fresh shoe.
    shoe.shuffle()

    for i in range(iterations):
        game_id = str(uuid.uuid4())

        # Insert just the game ID into the table
        cursor.execute('''INSERT INTO blackjack_statistics (id) VALUES (?)''', (game_id,))

        # Commit the initial insertion
        connection.commit()

        ###print(f'Game #{i+1}.')
        ###print('-------')
        # initialize dealer hand, player hand

        if shoe.amount_left() < 50: # checks to see if shoe is less than 50% full.
            #print('The shoe is less than 50 percent full. Re-shuffling the deck.')
            shoe = Shoe(shoe_size)
            shoe.shuffle()

        player, dealer = deal_initial_cards(shoe)

        initial_blackjack = check_initial_blackjack(player,dealer)

        db_init_hand = player.display_hand()[0][0],player.display_hand()[0][1]
        db_init_total_value = player.total_value()
        db_init_hand_type = initial_hand_type(player)
        db_dealer_up = str(dealer.show_upcard())

        cursor.execute('''UPDATE blackjack_statistics 
                  SET initial_hand_player = ?, init_total_player = ?, type = ?, dealer_up = ?
                  WHERE id = ?''', (str(db_init_hand), db_init_total_value, db_init_hand_type, db_dealer_up, game_id))
        
        connection.commit()

        # handling initial blackjack scenarios
        if initial_blackjack == 'pwin':
            cursor.execute('''UPDATE blackjack_statistics 
                  SET decision_init_player = ?, split = ?, dealer_total = ?, player_total = ?, win = ?, win_multiplier = ?
                  WHERE id = ?''', ('S', 'N', dealer.total_value(), player.total_value(), '1', 1.5, game_id))
        
            connection.commit()

            ###print(f'Player wins with initial blackjack. {player.display_hand()} Countinuing')

            continue

        elif initial_blackjack == 'dwin':
            cursor.execute('''UPDATE blackjack_statistics 
                  SET decision_init_player = ?, split = ?, dealer_total = ?, player_total = ?, win = ?, win_multiplier = ?
                  WHERE id = ?''', ('S', 'N', dealer.total_value(), player.total_value(), '-1', 1.5, game_id))
        
            connection.commit()

            ###print(f'Dealer wins with initial blackjack. {dealer.display_hand()} Countinuing')
            continue

        elif initial_blackjack == 'pbj':
            cursor.execute('''UPDATE blackjack_statistics 
                  SET decision_init_player = ?, split = ?, dealer_total = ?, player_total = ?, win = ?, win_multiplier = ?
                  WHERE id = ?''', ('S', 'N', dealer.total_value(), player.total_value(), '0', 1.5, game_id))
        
            connection.commit()

            ###print(f'It\'s a push! Dealer has {dealer.display_hand()} and player has {player.display_hand()} Countinuing')
            continue

        # Make decisions for initial hand
        initial_decision = initial_player_decision(player, dealer, shoe)
        
        # SQL
        db_init_decision = initial_decision
        cursor.execute('''UPDATE blackjack_statistics
            SET decision_init_player = ?, 
                split = CASE
                       WHEN ? = 'P' THEN 'Y'
                       ELSE 'N'
                    END,
                win_multiplier = CASE
                       WHEN ? = 'D' THEN 2
                       ELSE 1
                    END
            WHERE id = ?''', (db_init_decision, db_init_decision, db_init_decision, game_id))
        
        connection.commit()


        if initial_decision == 'H' and player.total_value() <= 21:
            player_decision(player,dealer,shoe)

        if initial_decision == 'P':
            # there can also technically be split blackjack wins

            for i in range(len(player.hands)):
                handtype = hand_type(player.hands[i])
                init_total = player.hands[i].total_value()
                initial_decision = initial_player_decision(player.hands[i],dealer,shoe,'N')

                if initial_decision == 'H' and player.total_value() <= 21:
                    player_decision(player,dealer,shoe)

                # might need to be modified for blackjacks.
                if initial_decision == 'D':
                    win_multiplier = 2
                else:
                    win_multiplier = 1
                
                if i == 0:
                    # Combine the two cards into a single string
                    split_init_hand = f"{player.hands[i].get_card_at_index(0)},{player.hands[i].get_card_at_index(1)}"
                    

                    # Execute the UPDATE statement with the correct values
                    cursor.execute('''
                        UPDATE blackjack_statistics
                        SET split_init_hand_1 = ?,
                            split_init_type_1 = ?,
                            split_decision_init_1 = ?,
                            split_total_1 = ?,
                            split_win_multiplier_1 = ?
                        WHERE id = ?
                    ''', (split_init_hand, handtype, initial_decision, init_total, win_multiplier, game_id))
                    
                    # Commit the transaction
                    connection.commit()

                if i == 1:
                    # Combine the two cards into a single string
                    split_init_hand = f"{player.hands[i].get_card_at_index(0)},{player.hands[i].get_card_at_index(1)}"
                    
                    # Execute the UPDATE statement with the correct values
                    cursor.execute('''
                        UPDATE blackjack_statistics
                        SET split_init_hand_2 = ?,
                            split_init_type_2 = ?,
                            split_decision_init_2 = ?,
                            split_total_2 = ?,
                            split_win_multiplier_2 = ?
                        WHERE id = ?
                    ''', (split_init_hand, handtype, initial_decision, init_total, win_multiplier, game_id))
                    
                    # Commit the transaction
                    connection.commit()
            



        # Evaluate dealer's turn
        dealer_turn_result = dealer_turn(dealer, shoe)

        # Now evaluate each hand's outcome
        for index, hand in enumerate(player.hands):
            ###print(f'Outcome for Hand #{index + 1}: {player.hands[index].display_hand(), player.hands[index].total_value()}')

            evaluate_hand_outcome(player, dealer, game_id)

    # cursor.execute('SELECT * FROM blackjack_statistics')

    # results = cursor.fetchall()
    # print(results)


        




def deal_initial_cards(shoe):
    '''
    This function is used to create and deal the initial cards to the players as well as the dealer.
    Creates a player of PlayerHand class and dealer of Hand class and adds two cards.
    Shoe loses 4 cards.
    '''
    player = PlayerHand()
    dealer = Hand()

    for _ in range(2):
        player.add_card(shoe.deal_card()) # by deafult this deals to the first hand in the deck.
        dealer.add_card(shoe.deal_card())
    
    ###print("Dealing initial cards...")
    ###print("Player's hand:", player.display_hand())
    ###print("Dealer's upcard:", dealer.show_upcard())

    return player, dealer

def check_initial_blackjack(player,dealer):
    '''
    This function is used in the main blackjack function. It's purpose is to evaluate wheter the
    player or dealer have hit blackjack. In the game of blackjack, a card total of 21 off the initial
    deal is an instant win.
    Takes the player and dealer hand as parameters, returns pwin to represent  an instant player win
    dwin is is used to represent a dealer win. pbj represents a push as both sides have blackjack
    If there is no return then there is no blackjack and
    the game can countinue as normal. 
    '''
    if player.total_value() == 21:
        if dealer.total_value() == 21:
            return 'pbj'
        return 'pwin'
    if dealer.total_value() ==  21:
        return 'dwin'
    return

def initial_player_decision(player,dealer,shoe,splitting='Y'):
    '''
    This function will be used to return a decision after the initial deal of cards.
    Parameters:
    player - the players hand, playerHand class
    dealer - the dealers hand
    shoe - the shoe that cards are being dealt from
    will return a decision, either H,S,D,P : Hit, stand, double, split.
    '''

    hand_type = initial_hand_type(player)
    decision = basicStrategy(hand_type, player, dealer.show_upcard())

    
    if decision == 'S':
        ###print(f'Stand. Player hand is {player.display_hand()}')
        return 'S'
    
    if decision == 'H':
        # if the player decides to hit, then they should be dealt a card.
        player.add_card(shoe.deal_card())
        ###print(f'Hit. Player hand is now {player.display_hand()}')
        return 'H'

    if splitting == 'N':
        pass
    else:    
        if decision == 'P':
            player.execute_split(shoe)
            ###(f'Split. Player hands are now {player.display_hand()}')

            return 'P'
    
    if decision[0] == 'D':
        player.add_card(shoe.deal_card())
        ###print(f'Doubling down. Player hand is now {player.display_hand()}')
        return 'D'
    
def player_decision(player,dealer,shoe):
    '''
    This function will be used to return a decision.
    Parameters:
    player - the players hand, playerHand class
    dealer - the dealers hand
    shoe - the shoe that cards are being dealt from
    will return a decision, either H,S : Hit, stand.
    '''
    if player.total_value() > 21:
            return

    type_hand = hand_type(player)
    decision = basicStrategy(type_hand, player, dealer.show_upcard())

    if len(decision) == 2:
        decision == decision[1]

    if decision == 'S':
        ###print(f'Stand. Player hand is {player.display_hand()}')
        return

    if decision == 'H':
        # if the player decides to hit, then they should be dealt a card.
        player.add_card(shoe.deal_card())
        ###print(f'Hit. Player hand is now {player.display_hand()}')
        player_decision(player,dealer,shoe)


def initial_hand_type(playerHand):
    '''
    Helper function for player decision.
    The purpose of this function is to return the type of hand the player has. This is required for basic strategy
    Types of hands
    Split: If the players two cards are the same then they can be "split" into two different hands. For instance, if the player is dealt two aces,
    and chooses to split, then the player will now have two hands. each of those hands will have an ace as well as a random card dealt from the shoe.
    Soft: A soft hand can be one of two values. This is because of blackjacks ace property. Aces are either counter as 1 or 11
    Hard: Every other type of hand is considered hard.
    '''
    if playerHand.can_split():
        # both hands are equal suit, they are under the split category
        return 'split'
    elif playerHand.is_soft():
        return 'soft'
    return 'hard'

def hand_type(playerHand,index=0):
    '''
    Helper function for player decision.
    The purpose of this function is to return the type of hand the player has. This is required for basic strategy
    Types of hands
    Soft: A soft hand can be one of two values. This is because of blackjacks ace property. Aces are either counter as 1 or 11
    Hard: Every other type of hand is considered hard.
    No split as this will be used after first turn.
    '''
    if playerHand.is_soft(index):
        return 'soft'
    return 'hard'
    
def dealer_turn(dealer,shoe):
    '''
    Used as a helper function inside of the blackjack function. This function is used after the players turn has concluded. The dealer will countinue to add cards to their
    deck until the total is greater than or equal to 17, or the dealer busts.
    Takes the dealers hand as a parameter and the shoe the game is being played with.
    Returns one of two values, dbust and dstay
    dbust means the dealer has busted. the player wins the hand
    dstay means the dealer has stayed on their hand. The dealer and player hand now has to go to a final evaluation.
    '''

    while dealer.total_value() < 17:
        dealer.add_card(shoe.deal_card())

    # now we have exited. If the dealer value is over 21 then the dealer has busted
    if dealer.total_value() > 21:
        return 'dbust'
    # otherwise, the dealer value is between 17 and 21. dealer is staying
    return 'dstay'

def evaluate_hand_outcome(player, dealer, game_id):
    player_total = player.total_value()
    dealer_total = dealer.total_value()

        # Determine outcome
    if player_total > 21:
        outcome = 'player_bust'
        game_win = -1
    elif dealer_total > 21:
        outcome = 'dealer_bust'
        game_win = 1
    elif player_total > dealer_total:
        outcome = 'player_win'
        game_win = 1
    elif player_total < dealer_total:
        outcome = 'dealer_win'
        game_win = -1
    else:
        outcome = 'push'
        game_win = 0

    # Update database with outcome
    cursor.execute('''UPDATE blackjack_statistics
                    SET win = ?,
                        outcome_type = ?,
                        player_total = ?,
                        dealer_total = ?
                    WHERE id = ?''', (game_win, outcome, player_total, dealer_total, game_id))

    connection.commit()

    # for debugging
    # print(f'dealer hand {dealer.display_hand(), dealer_total}')
    # # Print outcome (optional)
    # if outcome == 'player_bust':
    #     print("Player busts!")
    # elif outcome == 'dealer_bust':
    #     print("Dealer busts!")
    # elif outcome == 'player_win':
    #     print("Player wins!")
    # elif outcome == 'dealer_win':
    #     print("Dealer wins!")
    # else:
    #     print("It's a tie!")

def fetch_and_prepare_data(db_path):
    # Connect to SQLite database
    connection = sqlite3.connect(db_path)

    # Fetch the data
    query = '''
    SELECT init_total_player, dealer_up, win
    FROM blackjack_statistics
    '''
    df = pd.read_sql_query(query, connection)

    # Close the connection
    connection.close()

    # Calculate win rates
    win_rates = df.groupby(['init_total_player', 'dealer_up']).mean()['win'].unstack()

    # Define the desired order for dealer upcards
    dealer_upcard_order = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A']

    # Group J, Q, K, 10 together
    grouped_dealer_order = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A']

    # Sort columns based on the order defined above
    win_rates = win_rates[grouped_dealer_order]

    return win_rates

def create_3d_surface_plot(win_rates, save_path=None, interactive_path=None):
    fig = go.Figure(data=[go.Surface(z=win_rates.values, x=win_rates.columns, y=win_rates.index)])

    # Customize layout
    fig.update_layout(title='Win Rate by Initial Hand Total and Dealer Upcard',
                      scene=dict(
                          xaxis_title='Dealer Upcard',
                          yaxis_title='Player Initial Hand Total',
                          zaxis_title='Win Rate'),
                      autosize=False,
                      width=800, height=800)

    # Show plot
    fig.show()

    # Save plot if save_path is provided
    if save_path:
        fig.write_image(save_path)

    # Save interactive plot if interactive_path is provided
    if interactive_path:
        fig.write_html(interactive_path)

    # Show plot
    fig.show()

def fetch_and_plot_blackjack_statistics(db_path, save_path, interactive_path):
    win_rates = fetch_and_prepare_data(db_path)
    create_3d_surface_plot(win_rates, save_path, interactive_path)

save_path = 'E:\\Programming\\bj\\Blackjack-Statistics\\3d_heatmap.png'
interactive_path = 'E:\\Programming\\bj\\Blackjack-Statistics\\3d_heatmap.html'

if __name__=='__main__':
    blackjack_statistics(1000,4)
    #fetch_and_plot_blackjack_statistics('blackjack_statistics', save_path, interactive_path)



